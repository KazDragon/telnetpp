<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Telnet++: Telnet++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Telnet++<span id="projectnumber">&#160;4.0.0.9</span>
   </div>
   <div id="projectbrief">A C++ library for interacting with Telnet streams</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Telnet++ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2telnetpp_2telnetpp_2README"></a> <a href="https://kazdragon.github.io/telnetpp/"><img src="https://img.shields.io/badge/code-documented-brightgreen.svg?style=flat" alt="Documentation" style="pointer-events: none;" class="inline"/></a> <a href="https://en.wikipedia.org/wiki/MIT_License"><img src="https://img.shields.io/github/license/KazDragon/telnetpp.svg" alt="License" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/KazDragon/telnetpp/releases"><img src="https://img.shields.io/github/release/KazDragon/telnetpp.svg" alt="GitHub Releases" style="pointer-events: none;" class="inline"/></a> <a href="https://ci.appveyor.com/project/KazDragon/telnetpp/branch/master"><img src="https://ci.appveyor.com/api/projects/status/8mfv56qt8k2u4ibp/branch/master?svg=true" alt="MSVC Build status" class="inline"/></a> <a href="https://github.com/KazDragon/telnetpp/actions?query=event%3Apush"><img src="https://github.com/KazDragon/telnetpp/workflows/build/badge.svg" alt="Linux Build status" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/github/KazDragon/telnetpp?branch=master"><img src="https://coveralls.io/repos/github/KazDragon/telnetpp/badge.svg?branch=master" alt="Coverage Status" style="pointer-events: none;" class="inline"/></a> <a href="https://www.codacy.com/gh/KazDragon/telnetpp/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=KazDragon/telnetpp&amp;utm_campaign=Badge_Grade"><img src="https://app.codacy.com/project/badge/Grade/63ec54845f2c41f1899706c61f1c316b" alt="Codacy Badge" class="inline"/></a> <a href="https://github.com/KazDragon/telnetpp/issues"><img src="https://img.shields.io/github/issues/KazDragon/telnetpp.svg" alt="Github Issues" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="https://gitter.im/KazDragon/telnetpp?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img src="https://badges.gitter.im/KazDragon/telnetpp.svg" alt="Gitter" style="pointer-events: none;" class="inline"/></a></p>
<p>Telnet++ is an implementation of the Telnet Session Layer protocol that is used primarily to negotiate a feature set between a client and server, the former of which is usually some kind of text-based terminal, Commonly used terminals include Xterm, PuTTY, and a whole host of Telnet-enabled MUD clients including Tintin++, MushClient, and more.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Requirements</h1>
<p>Telnet++ requires a C++20 compiler and the following libraries:</p><ul>
<li>Boost (At least version 1.69.0)</li>
<li>(Optionally) ZLib</li>
<li>(For testing only) Google Test</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
Installation - CMake</h1>
<p>Telnet++ can be installed from source using CMake. This requires Boost and any other dependencies to have been installed beforehand, using their own instructions, or for the call to <code>cmake --configure</code> to be adjusted appropriately (e.g. <code>-DBOOST_ROOT=...</code>). If you do not wish to install into a system directory, and thus avoid the use of sudo, you can also pass <code>-DCMAKE_INSTALL_PREFIX=...</code> into the <code>cmake --configure</code> call. </p><pre class="fragment">git clone https://github.com/KazDragon/telnetpp.git &amp;&amp; cd telnetpp
mkdir build &amp;&amp; cd build
cmake --configure -DCMAKE_BUILD_TYPE=Release ..
cmake --build .
sudo cmake --install .
</pre> <h1><a class="anchor" id="autotoc_md11"></a>
Features / Roadmap / Progress</h1>
<ol type="1">
<li>[x] Basic constants and structures for use with Telnet<ul>
<li>[x] Constants such as IAC, SB, SE, WILL, WONT, DO, DONT</li>
<li>[x] Helper structures for commands, negotiations, and subnegotiations</li>
<li>[x] Parser that can convert a stream of bytes into a variant of commands, negotiations, subnegotiations and plain text.</li>
<li>[x] Generator that can convert a stream of the above-mentioned variant into a stream of bytes.</li>
</ul>
</li>
<li>[x] A framework for managing Telnet<ul>
<li>[x] Structures for client and server options</li>
<li>[x] A method of routing incoming negotiations and subnegotiations to the relevant options.</li>
</ul>
</li>
<li>[x] Reference implementations of various standard options<ul>
<li>[x] Arbitrary "subnegotiationless" options</li>
<li>[x] Echo</li>
<li>[x] NAWS</li>
<li>[x] Terminal Type</li>
<li>[x] New Environ</li>
</ul>
</li>
<li>[x] Reference implementations of some domain-specific options for MUDs<ul>
<li>[x] MSDP - the Mud Server Data Protocol (see <a href="http://tintin.sourceforge.net/msdp/">http://tintin.sourceforge.net/msdp/</a>)</li>
<li>[x] MCCP - the Mud Client Compression Protocol (see <a href="http://tintin.sourceforge.net/mccp/">http://tintin.sourceforge.net/mccp/</a>)</li>
</ul>
</li>
<li>[x] Structures to hide the complexity of the layer (e.g. routers, parsers, generators).<ul>
<li>[x] Session class that understands all of the helper structures and how to convert to and from a stream of bytes.</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md12"></a>
Status</h1>
<p>Telnet++ is automatically tested with MSVC 2022 and GNU g++ 13.3.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
The Basics</h1>
<p>The protocol has three basic elements, all of which are accessed by using the 0xFF character called "Interpret As Command", or IAC.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Commands</h2>
<p>Without needing to negotiate any capabilities, Telnet offers some out-of-the-box commands. These include Are You There, which is usually sent by the client to provoke a response from an otherwise-busy server; Erase Line, which could be used in interative applications to cancel a set of input, and several other commands used for negotiations between options.</p>
<p>Commands are represented by the <a href="include/telnetpp/command.hpp">telnetpp::command</a> class.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Negotiations</h2>
<p>The Telnet protocol describes a model whereby the client and server maintain separate lists of features, called "options", which can be enabled or disabled by the remote side. Individual options may each be described as "server" or "client" options, and server and client options may be mixed on each side of the connection. It is even possible in some cases that both sides of the connection can be both client and server for the same option. These options are negotiated by using the commands DO, DONT, WILL and WONT.</p>
<p>The various Telnet option specifications are not consistent in what is considered a server and what is considered a client, but for the purposes of this library, the server is considered as the side of the connection that does the thing, and the client is the side of the connection that wants the thing. That is, the server reacts to DO and DONT and sends WILL and WONT, and the client reacts to WILL and WONT and sends DO and DONT.</p>
<p>Negotiations are represented by the <a href="include/telnetpp/negotiation.hpp">telnetpp::negotiation</a> class.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Subnegotiations</h2>
<p>After an option has been negotiated, a new channel opens up to be able to communicate in an option-specific way to the remote terminal. These are called subnegotiations, and each protocol defines its own sub-protocol. For example, the NAWS (Negotiate About Window Size) sends five bytes when reporting window size, the first of which represents an "IS" token, and the following four bytes represent two two-byte pairs that are the window extends.</p>
<p>Subnegotiations are represented by the <a href="include/telnetpp/subnegotiation.hpp">telnetpp::subnegotiation</a> class.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Dataflow: Elements, Tokens and Streams</h1>
<p>A <a href="include/telnetpp/element.hpp">telnetpp::element</a> is a variant that may contain a command, a negotiation, a subnegotiation, or just a plain sequence of bytes representing non-Telnet-specific input/output.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Stream-Unaware</h1>
<p>The Telnet++ library does not impose any requirement on any kind of data stream API. In order to accomplish this, it makes heavy use of a channel concept. See the <a href="include/telnetpp/session.hpp">telnetpp::session</a> class for an in-depth explanation of how this works.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Options</h1>
<p>As alluded to earlier, each distinct feature is represented by either a <a href="include/telnetpp/client_option.hpp">telnetpp::client_option</a> or a <a href="include/telnetpp/server_option.hpp">telnetpp::server_option</a>. These both enjoy the same <a href="include/telnetpp/option.hpp">API</a>; they only differ in the underlying protocol. The user needs to know little about which actual negotiations and commands are sent. There are two key functions and one signal for the option classes:</p>
<ul>
<li>activate() - this is used to request activation on the remote side.</li>
<li>deactive() - this is used to request deactivation on the remote side.</li>
<li>on_state_changed - this is a signal that is called when the option is either being activated, active, being deactivated, or has become inactive.</li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
Session</h1>
<p>All of the above can be quite complicated to manage, so Telnet++ provides the <a href="include/telnetpp/session.hpp">telnetpp::session</a> class. This is the key abstraction of the Telnet++ library, and is used to manage an entire Telnet feature set for a connection. This is accomplished by "install"ing handlers for commands and options:</p>
<div class="fragment"><div class="line"><span class="comment">// A user-supplied class that models the channel concept</span></div>
<div class="line"><span class="keyword">class </span>channel {</div>
<div class="line">  <span class="keywordtype">void</span> write(telnetpp::bytes);</div>
<div class="line">  <span class="keywordtype">void</span> async_read(std::function&lt;<span class="keywordtype">void</span> (telnetpp::bytes)&gt;);</div>
<div class="line">  <span class="keywordtype">bool</span> is_alive() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> close();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">channel my_channel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a session object, which manages the inputs and outputs from my channel.</span></div>
<div class="line"><a class="code hl_class" href="classtelnetpp_1_1session.html">telnetpp::session</a> session{my_channel};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// An echo server (provided with Telnet++) is used to control whether a server responds to input from</span></div>
<div class="line"><span class="comment">// a client by transmitting the same text back to the client.  By default, this does not happen, and</span></div>
<div class="line"><span class="comment">// clients print out locally whatever is typed in.  By activating this option, the client no longer</span></div>
<div class="line"><span class="comment">// locally echos input, and the server is totally in control of what appears on the screen.</span></div>
<div class="line"><a class="code hl_class" href="classtelnetpp_1_1options_1_1echo_1_1server.html">telnetpp::options::echo::server</a> echo_server{session};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The session now knows we want this feature to be handled and does all the heavy lifting for us.</span></div>
<div class="line">session.install(echo_server);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// By default, options sit there in a deactivated state unless explicitly activated either locally</span></div>
<div class="line"><span class="comment">// in code or in protocol from the remote.  Here, we activate it ourselves.  This uses the session</span></div>
<div class="line"><span class="comment">// to ensure that the protocol bytes are forwarded to the channel.</span></div>
<div class="line">echo_server.activate();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sessions just pass on commands to functions installed on a per-command basis.  Here we pass a</span></div>
<div class="line"><span class="comment">// lambda to handle the Are You There command.</span></div>
<div class="line">session.install(</div>
<div class="line">    <a class="code hl_class" href="classtelnetpp_1_1command.html">telnetpp::command</a>{telnetpp::ayt},</div>
<div class="line">    [&amp;]</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// We respond here by forwarding plain text as a sequence of bytes via the session.</span></div>
<div class="line">        <span class="keyword">using </span>telnetpp::literals;</div>
<div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> message = <span class="stringliteral">&quot;Yes, I&#39;m here&quot;</span>_tb;</div>
<div class="line">        </div>
<div class="line">        <a class="code hl_class" href="classtelnetpp_1_1session.html">session</a>.<a class="code hl_function" href="classtelnetpp_1_1session.html#a142c0ca472d06debadd5f553b58ba4ea">write</a>(message, my_socket_send);</div>
<div class="line">    });</div>
<div class="ttc" id="aclasstelnetpp_1_1command_html"><div class="ttname"><a href="classtelnetpp_1_1command.html">telnetpp::command</a></div><div class="ttdoc">A class that encapsulates the value of a Telnet command.</div><div class="ttdef"><b>Definition</b> command.hpp:13</div></div>
<div class="ttc" id="aclasstelnetpp_1_1options_1_1echo_1_1server_html"><div class="ttname"><a href="classtelnetpp_1_1options_1_1echo_1_1server.html">telnetpp::options::echo::server</a></div><div class="ttdoc">An implementation of the server side of Telnet ECHO option.</div><div class="ttdef"><b>Definition</b> server.hpp:17</div></div>
<div class="ttc" id="aclasstelnetpp_1_1session_html"><div class="ttname"><a href="classtelnetpp_1_1session.html">telnetpp::session</a></div><div class="ttdoc">An abstraction for a Telnet session.</div><div class="ttdef"><b>Definition</b> session.hpp:141</div></div>
<div class="ttc" id="aclasstelnetpp_1_1session_html_a142c0ca472d06debadd5f553b58ba4ea"><div class="ttname"><a href="classtelnetpp_1_1session.html#a142c0ca472d06debadd5f553b58ba4ea">telnetpp::session::write</a></div><div class="ttdeci">void write(telnetpp::element const &amp;elem)</div><div class="ttdoc">Sends a Telnet data element. Translates the element into a sequence of bytes, that is then sent to th...</div><div class="ttdef"><b>Definition</b> session.cpp:96</div></div>
</div><!-- fragment --><p>Receiving data is slightly more complex since it is asynchronous and so requires a callback that is called when data is received.</p>
<div class="fragment"><div class="line"><span class="comment">// A user-specified function that transmits data up to the application.</span></div>
<div class="line"><span class="comment">// Note: the session indicates that an async_read is complete by sending</span></div>
<div class="line"><span class="comment">// an empty packet of data.  This can be used to prompt a new async_read,</span></div>
<div class="line"><span class="comment">// for example.</span></div>
<div class="line"><span class="keywordtype">void</span> my_application_receive(telnetpp::bytes data);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classtelnetpp_1_1session.html">session</a>.<a class="code hl_function" href="classtelnetpp_1_1session.html#a2f5b379db52bd9647dfc3112d3404cae">async_read</a>(</div>
<div class="line">    [&amp;](telnetpp::bytes data)</div>
<div class="line">    {</div>
<div class="line">        my_application_receive(data);</div>
<div class="line">    });</div>
<div class="ttc" id="aclasstelnetpp_1_1session_html_a2f5b379db52bd9647dfc3112d3404cae"><div class="ttname"><a href="classtelnetpp_1_1session.html#a2f5b379db52bd9647dfc3112d3404cae">telnetpp::session::async_read</a></div><div class="ttdeci">void async_read(std::function&lt; void(telnetpp::bytes)&gt; const &amp;callback)</div><div class="ttdoc">Requests data from the underlying channel, acting on any Telnet primitives that are received.</div><div class="ttdef"><b>Definition</b> session.cpp:66</div></div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 9 2025 16:28:24 for Telnet++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
