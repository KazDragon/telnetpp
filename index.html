<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Telnet++: Telnet++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Telnet++
   &#160;<span id="projectnumber">2.1.2</span>
   </div>
   <div id="projectbrief">A C++ library for interacting with Telnet streams</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Telnet++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://codedocs.xyz/KazDragon/telnetpp/"></a> <a href="https://en.wikipedia.org/wiki/MIT_License"></a> <a href="https://github.com/KazDragon/telnetpp/releases"></a> <a href="https://ci.appveyor.com/project/KazDragon/telnetpp/branch/master"></a> </p><div class="image">
<object type="image/svg+xml" data="https://github.com/KazDragon/telnetpp/workflows/build/badge.svg" alt="Linux Build status"></object>
</div>
<p> <a href="https://coveralls.io/github/KazDragon/telnetpp?branch=master"></a> <a href="https://www.codacy.com/app/KazDragon/telnetpp?utm_source=github.com&amp;amp;utm_medium=referral&amp;amp;utm_content=KazDragon/telnetpp&amp;amp;utm_campaign=Badge_Grade"></a> <a href="https://bintray.com/kazdragon/conan-public/telnetpp%3Akazdragon/_latestVersion"></a></p>
<p><a href="https://github.com/KazDragon/telnetpp/issues"></a></p>
<p><a href="https://gitter.im/KazDragon/telnetpp?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"></a></p>
<p>Telnet++ is an implementation of the Telnet Session Layer protocol that is used primarily to negotiate a feature set between a client and server, the former of which is usually some kind of text-based terminal, Commonly used terminals include Xterm, PuTTY, and a whole host of Telnet-enabled MUD clients including Tintin++, MushClient, and more.</p>
<h1>Requirements</h1>
<p>Telnet++ requires a C++14 compiler and the following libraries:</p><ul>
<li>Boost (At least version 1.69.0)</li>
<li>GSL-lite (Exactly version 1.34 until 1.38 is available, due to <a href="https://github.com/gsl-lite/gsl-lite/issues/270">This issue</a></li>
<li>(Optionally) ZLib</li>
<li>(For testing only) Google Test</li>
</ul>
<h1>Installation - CMake</h1>
<p>Telnet++ can be installed from source using CMake. This requires Boost, GSL-Lite and any other dependencies to have been installed beforehand, using their own instructions, or for the call to <code>cmake --configure</code> to be adjusted appropriately (e.g. <code>-DBOOST_ROOT=...</code> or <code>-Dgsl-lite_DIR=...</code>). If you do not wish to install into a system directory, and thus avoid the use of sudo, you can also pass <code>-DCMAKE_INSTALL_PREFIX=...</code> into the <code>cmake --configure</code> call. </p><pre class="fragment">git clone https://github.com/KazDragon/telnetpp.git &amp;&amp; cd telnetpp
mkdir build &amp;&amp; cd build
cmake --configure -DCMAKE_BUILD_TYPE=Release ..
cmake --build .
sudo cmake --install .
</pre><h1>Installation - Conan</h1>
<p>You can also use <a href="https://conan.io/">The Conan Package Manager</a> to install Telnet++ and its dependencies.</p>
<p>See <a href="examples/rot13server">the rot13server example</a> for a minimalistic project that describes this setup.</p>
<h1>Features / Roadmap / Progress</h1>
<ol type="1">
<li>[x] Basic constants and structures for use with Telnet<ul>
<li>[x] Constants such as IAC, SB, SE, WILL, WONT, DO, DONT</li>
<li>[x] Helper structures for commands, negotiations, and subnegotiations</li>
<li>[x] Parser that can convert a stream of bytes into a variant of commands, negotiations, subnegotiations and plain text.</li>
<li>[x] Generator that can convert a stream of the above-mentioned variant into a stream of bytes.</li>
</ul>
</li>
<li>[x] A framework for managing Telnet<ul>
<li>[x] Structures for client and server options</li>
<li>[x] A method of routing incoming negotiations and subnegotiations to the relevant options.</li>
</ul>
</li>
<li>[x] Reference implementations of various standard options<ul>
<li>[x] Arbitrary "subnegotiationless" options</li>
<li>[x] Echo</li>
<li>[x] NAWS</li>
<li>[x] Terminal Type</li>
<li>[x] New Environ</li>
</ul>
</li>
<li>[x] Reference implementations of some domain-specific options for MUDs<ul>
<li>[x] MSDP - the Mud Server Data Protocol (see <a href="http://tintin.sourceforge.net/msdp/">http://tintin.sourceforge.net/msdp/</a>)</li>
<li>[x] MCCP - the Mud Client Compression Protocol (see <a href="http://tintin.sourceforge.net/mccp/">http://tintin.sourceforge.net/mccp/</a>)</li>
</ul>
</li>
<li>[x] Structures to hide the complexity of the layer (e.g. routers, parsers, generators).<ul>
<li>[x] Session class that understands all of the helper structures and how to convert to and from a stream of bytes.</li>
</ul>
</li>
</ol>
<h1>Documentation</h1>
<p>Reference documentation is automatically generated and published to <a href="https://kazdragon.github.io/telnetpp/">https://kazdragon.github.io/telnetpp/</a></p>
<h1>Status</h1>
<p>Telnet++ is automatically tested with MSVC 2019 and GNU g++ 7.5.</p>
<h1>The Basics</h1>
<p>The protocol has three basic elements, all of which are accessed by using the 0xFF character called "Interpret As Command", or IAC.</p>
<h2>Commands</h2>
<p>Without needing to negotiate any capabilities, Telnet offers some out-of-the-box commands. These include Are You There, which is usually sent by the client to provoke a response from an otherwise-busy server; Erase Line, which could be used in interative applications to cancel a set of input, and several other commands used for negotiations between options.</p>
<p>Commands are represented by the <a href="include/telnetpp/command.hpp">telnetpp::command</a> class.</p>
<h2>Negotiations</h2>
<p>The Telnet protocol describes a model whereby the client and server maintain separate lists of features, called "options", which can be enabled or disabled by the remote side. Individual options may each be described as "server" or "client" options, and server and client options may be mixed on each side of the connection. It is even possible in some cases that both sides of the connection can be both client and server for the same option. These options are negotiated by using the commands DO, DONT, WILL and WONT.</p>
<p>The various Telnet option specifications are not consistent in what is considered a server and what is considered a client, but for the purposes of this library, the server is considered as the side of the connection that does the thing, and the client is the side of the connection that wants the thing. That is, the server reacts to DO and DONT and sends WILL and WONT, and the client reacts to WILL and WONT and sends DO and DONT.</p>
<p>Negotiations are represented by the <a href="include/telnetpp/negotiation.hpp">telnetpp::negotiation</a> class.</p>
<h2>Subnegotiations</h2>
<p>After an option has been negotiated, a new channel opens up to be able to communicate in an option-specific way to the remote terminal. These are called subnegotiations, and each protocol defines its own sub-protocol. For example, the NAWS (Negotiate About Window Size) sends five bytes when reporting window size, the first of which represents an "IS" token, and the following four bytes represent two two-byte pairs that are the window extends.</p>
<p>Subnegotiations are represented by the <a href="include/telnetpp/subnegotiation.hpp">telnetpp::subnegotiation</a> class.</p>
<h1>Dataflow: Elements, Tokens and Streams</h1>
<p>A <a href="include/telnetpp/element.hpp">telnetpp::element</a> is a Boost.Variant that may contain a command, a negotiation, a subnegotiation, or just a plain sequence of bytes representing non-Telnet-specific input/output.</p>
<h1>Stream-Unaware</h1>
<p>The Telnet++ library does not impose any requirement on any kind of data stream API. In order to accomplish this, it makes heavy use of continuation functions. See the <a href="include/telnetpp/session.hpp">telnetpp::session</a> class for an in-depth explanation of how this works.</p>
<h1>Options</h1>
<p>As alluded to earlier, each distinct feature is represented by either a <a href="include/telnetpp/client_option.hpp">telnetpp::client_option</a> or a <a href="include/telnetpp/server_option.hpp">telnetpp::server_option</a>. These both enjoy the same <a href="include/telnetpp/option.hpp">API</a>; they only differ in the underlying protocol. The user needs to know little about which actual negotiations and commands are sent. There are two key functions and one signal for the option classes:</p>
<ul>
<li>activate() - this is used to request activation on the remote side.</li>
<li>deactive() - this is used to request deactivation on the remote side.</li>
<li>on_state_changed - this is a signal that is called when the option is either being activated, active, being deactivated, or has become inactive.</li>
</ul>
<h1>Session</h1>
<p>All of the above can be quite complicated to manage, so Telnet++ provides the <a href="include/telnetpp/session.hpp">telnetpp::session</a> class. This is the key abstraction of the Telnet++ library, and is used to manage an entire Telnet feature set for a connection. This is accomplished by "install"ing handlers for commands and options:</p>
<div class="fragment"><div class="line">// A user-specified function for sending bytes to the remote.</div><div class="line">void my_socket_send(telnetpp::bytes data);</div><div class="line"></div><div class="line">// Create a session object, which manages the inputs and outputs from my connection.  It requires</div><div class="line">// a function that is to be called whenever non-Telnet input is received.</div><div class="line">telnetpp::session session;</div><div class="line"></div><div class="line">// An echo server (provided with Telnet++) is used to control whether a server responds to input from</div><div class="line">// a client by transmitting the same text back to the client.  By default, this does not happen, and</div><div class="line">// clients print out locally whatever is typed in.  By activating this option, the client no longer</div><div class="line">// locally echos input, and the server is totally in control of what appears on the screen.</div><div class="line">telnetpp::options::echo::server echo_server;</div><div class="line"></div><div class="line">// The session now knows we want this feature to be handled and does all the heavy lifting for us.</div><div class="line">session.install(echo_server);</div><div class="line"></div><div class="line">// By default, options sit there in a deactivated state unless explicitly activated either locally</div><div class="line">// in code or in protocol from the remote.  Here, we activate it ourselves, forwarding protocol</div><div class="line">// via the session, and eventually out through our user-specified function.</div><div class="line">echo_server.activate(</div><div class="line">    [&amp;](telnetpp::element const &amp;elem)</div><div class="line">    {</div><div class="line">        session.send(elem, my_socket_send);</div><div class="line">    });</div><div class="line"></div><div class="line">// Sessions just pass on commands to functions installed on a per-command basis.  Here we pass a</div><div class="line">// lambda to handle the Are You There command.</div><div class="line">session.install(</div><div class="line">    telnetpp::command{telnetpp::ayt},</div><div class="line">    [&amp;]</div><div class="line">    {</div><div class="line">        // We respond here by forwarding plain text as a sequence of bytes via the session.</div><div class="line">        using telnetpp::literals;</div><div class="line">        auto const message = &quot;Yes, I&#39;m here&quot;_tb;</div><div class="line"></div><div class="line">        session.send(message, my_socket_send);</div><div class="line">    });</div></div><!-- fragment --><p>Receiving data is slightly more complex in that any reception of data may require data to be sent, and so functions that receive data also have a continuation for what to do with the response.</p>
<div class="fragment"><div class="line">// A user-specified function used for receiving bytes sent from the</div><div class="line">// remote.</div><div class="line">int my_socket_receive(telnetpp::byte *buffer, int size);</div><div class="line"></div><div class="line">// A user-specified function that transmits data up to the application</div><div class="line">// Note that the second argument is used to tell the application how</div><div class="line">// it may send a respond to the data it receives.</div><div class="line">void my_application_receive(</div><div class="line">    telnetpp::bytes data,</div><div class="line">    std::function&lt;void (telnetpp::bytes)&gt; const &amp;send);</div><div class="line"></div><div class="line">telnetpp::byte my_buffer[1024];</div><div class="line">int amount_received = my_socket_receive(my_buffer, 1024);</div><div class="line"></div><div class="line">session.receive(</div><div class="line">    telnetpp::bytes{my_buffer, amount_received},</div><div class="line">    my_application_receive,</div><div class="line">    my_socket_send);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 12 2020 19:33:32 for Telnet++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
