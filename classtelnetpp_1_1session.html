<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Telnet++: telnetpp::session Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Telnet++
   &#160;<span id="projectnumber">3.0.0.4</span>
   </div>
   <div id="projectbrief">A C++ library for interacting with Telnet streams</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>telnetpp</b></li><li class="navelem"><a class="el" href="classtelnetpp_1_1session.html">session</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtelnetpp_1_1session-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">telnetpp::session Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstraction for a Telnet session.  
 <a href="classtelnetpp_1_1session.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="session_8hpp_source.html">session.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aabe493f86cbe3315c7c4447d67fea6b3"><td class="memTemplParams" colspan="2"><a id="aabe493f86cbe3315c7c4447d67fea6b3"></a>
template&lt;typename Channel &gt; </td></tr>
<tr class="memitem:aabe493f86cbe3315c7c4447d67fea6b3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a> (Channel &amp;channel)</td></tr>
<tr class="memdesc:aabe493f86cbe3315c7c4447d67fea6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:aabe493f86cbe3315c7c4447d67fea6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab295ec67d51602dc7b9af40611339a34"><td class="memItemLeft" align="right" valign="top"><a id="ab295ec67d51602dc7b9af40611339a34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#ab295ec67d51602dc7b9af40611339a34">~session</a> ()</td></tr>
<tr class="memdesc:ab295ec67d51602dc7b9af40611339a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab295ec67d51602dc7b9af40611339a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeae015193152c241cd3f5144544443f"><td class="memItemLeft" align="right" valign="top"><a id="afeae015193152c241cd3f5144544443f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#afeae015193152c241cd3f5144544443f">is_alive</a> () const</td></tr>
<tr class="memdesc:afeae015193152c241cd3f5144544443f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the session is still alive. <br /></td></tr>
<tr class="separator:afeae015193152c241cd3f5144544443f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f5579c712c3802fc54e4c81f2eccda"><td class="memItemLeft" align="right" valign="top"><a id="a61f5579c712c3802fc54e4c81f2eccda"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#a61f5579c712c3802fc54e4c81f2eccda">close</a> ()</td></tr>
<tr class="memdesc:a61f5579c712c3802fc54e4c81f2eccda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the session. <br /></td></tr>
<tr class="separator:a61f5579c712c3802fc54e4c81f2eccda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5b379db52bd9647dfc3112d3404cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#a2f5b379db52bd9647dfc3112d3404cae">async_read</a> (std::function&lt; void(telnetpp::bytes)&gt; const &amp;callback)</td></tr>
<tr class="memdesc:a2f5b379db52bd9647dfc3112d3404cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests data from the underlying channel, acting on any Telnet primitives that are received.  <a href="classtelnetpp_1_1session.html#a2f5b379db52bd9647dfc3112d3404cae">More...</a><br /></td></tr>
<tr class="separator:a2f5b379db52bd9647dfc3112d3404cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142c0ca472d06debadd5f553b58ba4ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#a142c0ca472d06debadd5f553b58ba4ea">write</a> (<a class="el" href="classtelnetpp_1_1element.html">telnetpp::element</a> const &amp;elem)</td></tr>
<tr class="memdesc:a142c0ca472d06debadd5f553b58ba4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a Telnet data element. Translates the element into a sequence of bytes, that is then sent to the continuation.  <a href="classtelnetpp_1_1session.html#a142c0ca472d06debadd5f553b58ba4ea">More...</a><br /></td></tr>
<tr class="separator:a142c0ca472d06debadd5f553b58ba4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec3e554d8928b13863a03d3ac797d9d"><td class="memItemLeft" align="right" valign="top"><a id="a8ec3e554d8928b13863a03d3ac797d9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#a8ec3e554d8928b13863a03d3ac797d9d">install</a> (telnetpp::command_type cmd, std::function&lt; void(<a class="el" href="classtelnetpp_1_1command.html">telnetpp::command</a>)&gt; const &amp;handler)</td></tr>
<tr class="memdesc:a8ec3e554d8928b13863a03d3ac797d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a handler for the given command. <br /></td></tr>
<tr class="separator:a8ec3e554d8928b13863a03d3ac797d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b35fbb138b54db5e2d7149787b26eb"><td class="memItemLeft" align="right" valign="top"><a id="af7b35fbb138b54db5e2d7149787b26eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#af7b35fbb138b54db5e2d7149787b26eb">install</a> (<a class="el" href="classtelnetpp_1_1client__option.html">telnetpp::client_option</a> &amp;<a class="el" href="classtelnetpp_1_1option.html">option</a>)</td></tr>
<tr class="memdesc:af7b35fbb138b54db5e2d7149787b26eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a client option. <br /></td></tr>
<tr class="separator:af7b35fbb138b54db5e2d7149787b26eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be8b18145828395f63d1f5f78848e1a"><td class="memItemLeft" align="right" valign="top"><a id="a4be8b18145828395f63d1f5f78848e1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtelnetpp_1_1session.html#a4be8b18145828395f63d1f5f78848e1a">install</a> (<a class="el" href="classtelnetpp_1_1server__option.html">telnetpp::server_option</a> &amp;<a class="el" href="classtelnetpp_1_1option.html">option</a>)</td></tr>
<tr class="memdesc:a4be8b18145828395f63d1f5f78848e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a server option. <br /></td></tr>
<tr class="separator:a4be8b18145828395f63d1f5f78848e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstraction for a Telnet session. </p>
<dl class="section user"><dt>Overview</dt><dd>The session is the heart of the library, and ties all of the other components together. It manages all of the options that a session wishes to implement and ensures that data flows to them appropriately.</dd></dl>
<dl class="section user"><dt>The Channel</dt><dd>To be as agnostic as possible as to how to send and receive data, the session exposes a channel concept, which is fulfilled by any object that contains the functions: write, async_read, is_alive, close. Classes that expose these functions, such as tcp_socket in Server++, can be dropped in here without any extra work. Otherwise it may be necessary to write a small wrapper.</dd></dl>
<dl class="section user"><dt>Sending and Receiving Plain Data</dt><dd></dd></dl>
<p>The first part of using a <a class="el" href="classtelnetpp_1_1session.html" title="An abstraction for a Telnet session.">telnetpp::session</a> is understanding how to send and receive data. Even if no options are used during a session, this is still necessary because some data needs special handling.</p>
<dl class="section note"><dt>Note</dt><dd>According to the Telnet protocol, the 0xFF byte has to be transmitted as IAC IAC (0xFF 0xFF) so that it is not understood to be part of a Telnet protocol sequence. Likewise, it is necessary to parse IAC IAC into a single 0xFF byte.</dd></dl>
<p>Sending data uses the <a class="el" href="classtelnetpp_1_1session.html#a142c0ca472d06debadd5f553b58ba4ea" title="Sends a Telnet data element. Translates the element into a sequence of bytes, that is then sent to th...">telnetpp::session::write</a> function. This handles any such special sequences and then passes that data onto the continuation supplied. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>terminalpp::literals;</div>
<div class="line"><span class="keyword">struct </span>my_channel</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classtelnetpp_1_1session.html#a2f5b379db52bd9647dfc3112d3404cae">async_read</a>(std::function&lt;<span class="keywordtype">void</span> (telnetpp::bytes)&gt;);</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classtelnetpp_1_1session.html#a142c0ca472d06debadd5f553b58ba4ea">write</a>(telnetpp::bytes);</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">my_channel channel;</div>
<div class="line"><a class="code" href="classtelnetpp_1_1session.html">telnetpp::session</a> session{channel};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <span class="keyword">const</span> message = <span class="stringliteral">&quot;Hello&quot;</span> <span class="stringliteral">&quot;\xFF&quot;</span> <span class="stringliteral">&quot;World&quot;</span>_tb;</div>
<div class="line">session.send(message);</div>
<div class="line"><span class="comment">// sends &quot;Hello\xFF\xFFWorld&quot; to channel.write().</span></div>
<div class="line"><span class="comment">// Notice the duplicated \xFF byte as required by the Telnet protocol.</span></div>
<div class="ttc" id="aclasstelnetpp_1_1session_html"><div class="ttname"><a href="classtelnetpp_1_1session.html">telnetpp::session</a></div><div class="ttdoc">An abstraction for a Telnet session.</div><div class="ttdef"><b>Definition:</b> session.hpp:140</div></div>
<div class="ttc" id="aclasstelnetpp_1_1session_html_a142c0ca472d06debadd5f553b58ba4ea"><div class="ttname"><a href="classtelnetpp_1_1session.html#a142c0ca472d06debadd5f553b58ba4ea">telnetpp::session::write</a></div><div class="ttdeci">void write(telnetpp::element const &amp;elem)</div><div class="ttdoc">Sends a Telnet data element. Translates the element into a sequence of bytes, that is then sent to th...</div><div class="ttdef"><b>Definition:</b> session.cpp:95</div></div>
<div class="ttc" id="aclasstelnetpp_1_1session_html_a2f5b379db52bd9647dfc3112d3404cae"><div class="ttname"><a href="classtelnetpp_1_1session.html#a2f5b379db52bd9647dfc3112d3404cae">telnetpp::session::async_read</a></div><div class="ttdeci">void async_read(std::function&lt; void(telnetpp::bytes)&gt; const &amp;callback)</div><div class="ttdoc">Requests data from the underlying channel, acting on any Telnet primitives that are received.</div><div class="ttdef"><b>Definition:</b> session.cpp:66</div></div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd></dd></dl>
<p>Receiving data works using a continuation; a function that is called once the data is received. This means that it is non-blocking. Example:</p>
<div class="fragment"><div class="line">my_channel channel;</div>
<div class="line"><a class="code" href="classtelnetpp_1_1session.html">telnetpp::session</a> <a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>{channel};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A user-specified function that transmits data up to the application</span></div>
<div class="line"><span class="comment">// Note that the second argument is used to tell the application how</span></div>
<div class="line"><span class="comment">// it may send a respond to the data it receives.</span></div>
<div class="line"><span class="keywordtype">void</span> my_application_receive(telnetpp::bytes data);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>.async_read([&amp;](telnetpp::bytes data) {</div>
<div class="line">    my_application_receive(data);</div>
<div class="line">});</div>
<div class="ttc" id="aclasstelnetpp_1_1session_html_aabe493f86cbe3315c7c4447d67fea6b3"><div class="ttname"><a href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">telnetpp::session::session</a></div><div class="ttdeci">session(Channel &amp;channel)</div><div class="ttdoc">Constructor.</div><div class="ttdef"><b>Definition:</b> session.hpp:146</div></div>
</div><!-- fragment --><dl class="section user"><dt>Using Telnet Options</dt><dd></dd></dl>
<p>Now that we can send and receive data over a Telnet connection, the next step is to install some options. This allows the session to automatically route messages to and from these options as part of the normal data flow. Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classtelnetpp_1_1session.html">telnetpp::session</a> <a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>{channel};</div>
<div class="line"><a class="code" href="classtelnetpp_1_1options_1_1echo_1_1client.html">telnetpp::options::echo::client</a> echo_client{<a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>};</div>
<div class="line"><a class="code" href="classtelnetpp_1_1options_1_1naws_1_1server.html">telnetpp::options::naws::server</a> naws_server{<a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>};</div>
<div class="line"><a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>.install(echo_client);</div>
<div class="line"><a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>.install(naws_server);</div>
<div class="ttc" id="aclasstelnetpp_1_1options_1_1echo_1_1client_html"><div class="ttname"><a href="classtelnetpp_1_1options_1_1echo_1_1client.html">telnetpp::options::echo::client</a></div><div class="ttdoc">An implementation of the client side of Telnet ECHO option.</div><div class="ttdef"><b>Definition:</b> client.hpp:17</div></div>
<div class="ttc" id="aclasstelnetpp_1_1options_1_1naws_1_1server_html"><div class="ttname"><a href="classtelnetpp_1_1options_1_1naws_1_1server.html">telnetpp::options::naws::server</a></div><div class="ttdoc">An implementation of the server side of the Telnet NAWS option.</div><div class="ttdef"><b>Definition:</b> server.hpp:15</div></div>
</div><!-- fragment --><p>With these options installed, the normal message as implemented above will automatically activate or deactivate the options if this is requested by the remote. It is, of course, just fine if you want to activate these options yourself. Example:</p>
<div class="fragment"><div class="line">Transmits IAC WILL NAWS to the remote.</div>
<div class="line">naws_server.activate();</div>
</div><!-- fragment --><p>Likewise, any functions that cause option-specific negotiation (subnegotiations) to occur use a similar pattern:</p>
<div class="fragment"><div class="line"><span class="comment">// Will transmit IAC SB NAWS 00 80 00 24 IAC SE to the</span></div>
<div class="line"><span class="comment">// remote.</span></div>
<div class="line">naws_server.set_window_size(80, 24);</div>
</div><!-- fragment --><dl class="section user"><dt>Using Telnet Commands</dt><dd></dd></dl>
<p>There also exist a small number of Telnet commands, such as AYT (Are You There), BRK (Break) and NOP (No Operation). These can be sent using the telnetpp::session::send function in a similar way to plain text. Example:</p>
<div class="fragment"><div class="line"><a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>.write(<a class="code" href="classtelnetpp_1_1command.html">telnetpp::command</a>{telnetpp::ayt});</div>
<div class="ttc" id="aclasstelnetpp_1_1command_html"><div class="ttname"><a href="classtelnetpp_1_1command.html">telnetpp::command</a></div><div class="ttdoc">A class that encapsulates the value of a Telnet command.</div><div class="ttdef"><b>Definition:</b> command.hpp:12</div></div>
</div><!-- fragment --><p>They can also have handlers registered in order to respond to them:</p>
<div class="fragment"><div class="line"><a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>.install(</div>
<div class="line">    <a class="code" href="classtelnetpp_1_1command.html">telnetpp::command</a>{telnetpp::ayt},</div>
<div class="line">    [&amp;]()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using</span> telnetpp::literals;</div>
<div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> message = <span class="stringliteral">&quot;Yes, I&#39;m here&quot;</span>_tb;</div>
<div class="line">        <a class="code" href="classtelnetpp_1_1session.html#aabe493f86cbe3315c7c4447d67fea6b3">session</a>.write(message);</div>
<div class="line">    });</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f5b379db52bd9647dfc3112d3404cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5b379db52bd9647dfc3112d3404cae">&#9670;&nbsp;</a></span>async_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void telnetpp::session::async_read </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(telnetpp::bytes)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests data from the underlying channel, acting on any Telnet primitives that are received. </p>
<p>Note: the callback may be called several times for any async_read. For an example, it may contain two pieces of regular text surrounding a block of negotiation, which may change the way those two pieces of text are interpreted. For this reason, after an async_read is complete, the callback will always be called with an empty parameter to indicate that a new read request can be made. </p>

</div>
</div>
<a id="a142c0ca472d06debadd5f553b58ba4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142c0ca472d06debadd5f553b58ba4ea">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void telnetpp::session::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtelnetpp_1_1element.html">telnetpp::element</a> const &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a Telnet data element. Translates the element into a sequence of bytes, that is then sent to the continuation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The data to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/telnetpp/telnetpp/include/telnetpp/<a class="el" href="session_8hpp_source.html">session.hpp</a></li>
<li>/home/runner/work/telnetpp/telnetpp/src/session.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 5 2024 13:22:37 for Telnet++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
